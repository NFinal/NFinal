<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title></title>
	<meta charset="utf-8" />
</head>
<body>
    <pre>
	5.数据库的筛选。
	1.对于数所库的筛选，bit,最快。然后是int,like的效率最差。
	例如：汽车分为1-5万，5-10万，10-15万，15-20万，20万-50万，50万以上，价格未定几种范围。
	一般的筛选为：select * from car where price>10000 and price  <=50000
    select * from car where price>50000 and price  <=100000
	......
	如果我在表中建立一个索引字段price_select，用0代表价格未定，用1代表1万到5万，2代表5万到10万，3代表10万到20万。。。
	那么sql语句就变成了。select * from car where price_select=1
    select * from car where price_select=2
	.....
	还有些搜索条件是可以复合的。
	例如：某辆车有没有天窗，有没有GPS导航，有没有空调，有没有空气净化器等等。
	这种情况下，我们往往会如此设计：
	TianChuang(天窗) bit,一个字段。
	GPS(GPS导航) bit，一个字段。
	KongTiao(空调) bit，一个字段。
	JingHuaQi(净化器) bit,一个字段。
	。。。。。
	但是这样的设计其实并不合理，一方面数库在查询的时候速度会有一定的影响。
	另一方面，在用户要带有天窗，GPS导航，空调，净化器的汽车时，就要进行http的post请求时每一个字段都要解析。
	因此可以把这种有或没有的字段，合并为一个字段 select_prop。
	一个int类型有32位，可以存储32位这样的字段。
	0000 0000 0000 0000 0000 0000 0000 0001就是十进制数字1
    0000 0000 0000 0000 0000 0000 0000 0010就是十进制数字2
    0000 0000 0000 0000 0000 0000 0000 0100就是十进制数字4
    0000 0000 0000 0000 0000 0000 0000 1000就是十进制数字8
	由上图可以看出。某一位为1就代表具有该属性。
	例如
	select * from car where select_prop&1!=0 有天窗的汽车
    select * from car where select_prop&2!=0 有GPS导航的汽车
    select * from car where select_prop&(1+2)!=0 即有天窗，又有GPS的汽车
	也就是说前台只要传过来一个数字，就可以针到32种属性进行复合筛选，相当划算。
	2.自学习型筛选。
	当某个人搜索 “朗逸”两个字去搜索汽车时，程序会利用like进行搜索。速度是相对较慢的。
	当10个人去搜索这个词时，让程序去记录下来所有的汽车id，并放入keyword表中。
	这样下次查询时，先查询keyword,如果有则直接返回id然后再利用id查询，这样让程序自学习，自优化。
	当然这里仅仅是抛砖引玉。关于搜索优化，可以学习一下Lucene.net。
	</pre>
</body>
</html>
